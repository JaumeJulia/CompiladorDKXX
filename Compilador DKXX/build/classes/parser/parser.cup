package parser;

import java_cup.runtime.*;
import ArbolSintactico.ArbolSintactico;
import ArbolSintactico.ArbolSintactico.*;
import ArbolSintactico.Tipo;
import java.util.LinkedList;
import java.util.List;
import java.util.ArrayList;
import Semantico.TablaSimbolos;
import Semantico.Simbolo;
import Semantico.TipoSub;
import java.util.Stack;

parser code {:
    ArbolSintactico arbol= new ArbolSintactico();
    ArrayList<String> errores = new ArrayList<>();
    TablaSimbolos ts = new TablaSimbolos();

    public ArbolSintactico getArbol(){
        return arbol;
    }

    public TablaSimbolos getTablaSimbolos(){
        return ts;
    }

    public void newBloque(Symbol sym){
        ts.addLoc(sym.left, sym.right);
        ts.addnivel();
    }

    public void newValor (Symbol sym){
        ts.addLoc(sym.left, sym.right);
    }

    //Analisis Semantico #######################################################

    //Puntero de posiciones
    Stack<int[]> posicion = new Stack<>();

    private void put(Symbol cur_Token){
        int[] i = {cur_Token.left, cur_Token.right};
        posicion.push(i);
    }

    //Verificar si es funcion o asignacion.
    public void seleccionID(String id, SentenciaId sid){
        if(sid.expr != null){
            verificaAsig(id, sid.expr);
        } else {
            verificaFunc(id, sid.par);
        }
    }

    //Verifica que exista el id
    public boolean verificaID(String id){
        int[] pos = posicion.pop();
        Simbolo s = ts.getSimbolo(id);
        if(s == null){
            ts.addError(1, pos[0], pos[1], id);
            return false;
        }
        return true;
    }

    //Verifica Asignacion Const
    public void verificaAsigConst(String id, Expresion e) {
        int[] pos = posicion.pop();
        Simbolo s = ts.getSimbolo(id);
        if (s != null) {
            if (e == null){
                ts.addError(8, pos[0], pos[1], id);
            } else {
                if(!verificarExpr(e, s.getTipo())){
                    ts.addError(0, pos[0], pos[1], s.getTipo().toString());
                }
            } 
        }else {
            ts.addError(1, pos[0], pos[1], id);
        }
    }

    //Verifica Asignacion
    public boolean verificaAsig(String id, Expresion e){
        int[] pos = posicion.pop();
        Simbolo s = ts.getSimbolo(id);
        if(s != null){
            switch (s.getTipoSub()) {
                case PARAMETRO:
                case VARIABLE:
                    if(e != null && !verificarExpr(e, s.getTipo())){
                        ts.addError(0, pos[0], pos [1], s.getTipo().toString());
                    }   break;
                case FUNCION:
                    ts.addError(5, pos[0], pos [1], id);
                    break;
                default:
                    ts.addError(2, pos[0], pos[1], id);
                    break;
            }
        } else {
            ts.addError(1, pos[0], pos[1], id);
        }
        return false;   
    }

    //Verifica Funcion
    public boolean verificaFunc(String id, Param par){
        return false;
    }

    //Verifica RTN
    public boolean verificarRtn(String id, Sentencias s){
        return false;
    }

    //Verifica Expresion
    public boolean verificarExpr(Expresion e, Tipo t) {
        return true;
    }

    //Prioridad de operaciones.
    private Expresion PrioridadOperacion(Expresion e) {
        // Se verifica que haya dos operaciones.
        if (e.getOper() != null && e.getOper().getExpr().getOper() != null) {
            Operaciones OpActual = e.getOper().getOper();
            Operaciones OpAnterior = e.getOper().getExpr().getOper().getOper();
            // Se mira el orden de prioridad para reorganizar los valores.
            if (OpActual.compareTo(OpAnterior) < 0) {
                Operacion op = e.getOper().getExpr().getOper();
                e.getOper().getExpr().setOper(null);

                // Si hay una expresion vacia esta se elimina para evitar problemas.
                if(e.getOper().getExpr().getOper() == null && e.getOper().getExpr().isExpr()){
                    Expresion a = e.getOper().getExpr().getExpr();
                    e.getOper().setExpr(a);
                }
                // Se llama de forma recursiva con la nueva expresion para organizar las operaciones en ella.
                Expresion new_e = new Expresion(PrioridadOperacion(e), op);
                return new_e;
            }
        }
        return e;
    }

    //Tratamiento errores.
    @Override
    public void syntax_error(Symbol cur_token) {
        String mensaje = "\t - " + cur_token.toString() + "." + this.showExpectedTokenIds() + " en linea " + cur_token.left + " en columna " + cur_token.right;
        this.report_error(mensaje, cur_token);
    }

    @Override
    public void report_fatal_error(String mensaje, Object info) {
        //report_error(mensaje, null);
    }

    @Override
    public void report_error(String mensaje, Object info) {
        errores.add(mensaje);
    }

    private String showExpectedTokenIds() {
        List<Integer> ids = this.expected_token_ids();
        LinkedList<String> list = new LinkedList<>();
        for (Integer expected : ids) {
            list.add(this.symbl_name_from_id(expected.intValue()));
        }
        if (list.size() > 0) {
            return " Se esperaba: " + list.toString();
        } else {
            return "";
        }
    }

    public boolean hayErrores(){
        return !errores.isEmpty();
    }

    public String toStringErrores(){
        String s = "";
        for(String e : errores){
            s += e + "\n";
        }
        return s;
    }
:};



terminal    MULT, DIV, SUMA, RESTA, IGUAL, MAYORQUE, MENORQUE, MAYORIGU, MENORIGU, 
            IGUALES, OR, AND, LPAREN, RPAREN, LKEY, RKEY, RETRN, WHILE, IF, NIGUALES,
            OUT, IN, COMA, PUNTYCOMA, FUNCTION, CONST, INT, BOOL, DECLARE, MAIN;

terminal        String      ID;
terminal        String      NUMERO;
terminal        String      BOLEAN;

non terminal    Init        INIT;
non terminal    Def         DEF;

non terminal    Dfuncion    DFUNCION;
non terminal    Tipo        RETURN;
non terminal    Dparam      PARAMETRO;
non terminal    Dparam      PARAMCONCAT;
non terminal    Declaracion DECLARACION;
non terminal    Expresion   DECLAREND;
non terminal    Tipo        TYPE;
non terminal    Expresion   ASIGNACION;
non terminal    Expresion   EXPRESION;
non terminal    Valor       VALOR;
non terminal    Operacion   OPERACION;
non terminal    Operaciones OP;
non terminal    Param       FUNCION;
non terminal    Param       INPARAM;

non terminal Sentencia      SENTENCIA;
non terminal Sentencias     SENTENCIAS;
non terminal SentenciaId    SENTENCIA_ID;

non terminal Sentencias     R_SENTENCIAS;
non terminal Sentencia      R_SENTENCIA;

non terminal                MF;
non terminal                MV;
non terminal                M;

start with INIT;

INIT    ::=     DECLARE LKEY DEF:d RKEY MAIN LKEY SENTENCIAS:m RKEY
                {: arbol.setRaiz(new Init(d, m)); :}
        ;

/** sentencias por prog antes **/

DEF     ::=    DFUNCION:f DEF:d {:RESULT = new Def(f,d); :}
        |      DECLARACION:f PUNTYCOMA DEF:d {: RESULT = new Def(f, d); :}
        |      {:   :}
        ;

SENTENCIAS ::= SENTENCIA:e SENTENCIAS:s {: RESULT = new Sentencias(e, s); :}
        |   {: :}
        ;

SENTENCIA ::= DECLARACION:d  PUNTYCOMA                         {: RESULT= new Sentencia(d); :}
        | OUT LPAREN M EXPRESION:e RPAREN PUNTYCOMA              {: verificarExpr(e, Tipo.INT); RESULT= new Sentencia(new Out(e)); :}
        | M ID:i SENTENCIA_ID:d PUNTYCOMA                          {: seleccionID(i, d); RESULT= new Sentencia(new IdSentencia(new Id(i), d)); :}
        | WHILE LPAREN M EXPRESION:e RPAREN LKEY SENTENCIAS:s RKEY {: verificarExpr(e, Tipo.BOOLEAN); RESULT= new Sentencia(new While(e, s));  :}
        | IF LPAREN M EXPRESION:e RPAREN LKEY SENTENCIAS:s RKEY    {: verificarExpr(e, Tipo.BOOLEAN); RESULT= new Sentencia(new If(e, s)); :}
        | error PUNTYCOMA                                    {: parser.report_error("sentencia", "WRONG"); :}
        ;

R_SENTENCIAS ::= R_SENTENCIA:e R_SENTENCIAS:s {: RESULT= new Sentencias(e,s); :}
        |   {:  :}
        ;

R_SENTENCIA    ::= RETRN EXPRESION:e PUNTYCOMA  {: RESULT= new Sentencia(new Return(e)); :}
        | DECLARACION:d  PUNTYCOMA                         {: RESULT= new Sentencia(d); :}
        | OUT LPAREN M EXPRESION:e RPAREN PUNTYCOMA              {: verificarExpr(e, Tipo.INT); RESULT= new Sentencia(new Out(e)); :}
        | M ID:i SENTENCIA_ID:d PUNTYCOMA                          {: seleccionID(i, d); RESULT= new Sentencia(new IdSentencia(new Id(i), d)); :}
        | WHILE LPAREN M EXPRESION:e RPAREN LKEY R_SENTENCIAS:s RKEY {: verificarExpr(e, Tipo.BOOLEAN); RESULT= new Sentencia(new While(e, s));  :}
        | IF LPAREN M EXPRESION:e RPAREN LKEY R_SENTENCIAS:s RKEY    {: verificarExpr(e, Tipo.BOOLEAN); RESULT= new Sentencia(new If(e, s)); :}
        | error PUNTYCOMA                                    {: parser.report_error("sentencia", "WRONG"); :}
        ;

SENTENCIA_ID    ::= ASIGNACION:a {: RESULT= new SentenciaId(a); :}
                | FUNCION:f {: RESULT= new SentenciaId(f); :}
                ;


DFUNCION    ::= FUNCTION M RETURN:r MF ID:i LPAREN PARAMETRO:p RPAREN LKEY R_SENTENCIAS:s RKEY {: ts.addSimbolo(i, r, TipoSub.FUNCION); verificarRtn(i, s); RESULT= new Dfuncion(new Id(i), r, p, s); :}
            ;

RETURN      ::= TYPE:t {: RESULT= t; :}
            | {:  :}
            ;

PARAMETRO   ::= TYPE:t MV ID:i PARAMCONCAT:d {: ts.addSimbolo(i, t, TipoSub.PARAMETRO); RESULT= new Dparam(t, new Id(i), d); :}
            | {:  :}
            ;

PARAMCONCAT ::= COMA TYPE:t MV ID:i PARAMCONCAT:d {: ts.addSimbolo(i, t, TipoSub.PARAMETRO); RESULT= new Dparam(t, new Id(i), d); :}
            | {:  :}
            ;

DECLARACION ::= CONST M TYPE:t MV ID:i DECLAREND:d {: if(ts.addSimbolo(i, t, TipoSub.CONSTANTE)){verificaAsigConst(i, d);;} RESULT= new Declaracion(t, new Id(i), d); :}
            | M TYPE:t MV ID:i DECLAREND:d {: if(ts.addSimbolo(i, t, TipoSub.VARIABLE)){verificaAsig(i, d);} RESULT= new Declaracion(t, new Id(i), d); :}
            ;

DECLAREND   ::= ASIGNACION:a {: RESULT= a; :}
            | {:  :}
            ;

TYPE        ::= INT {: RESULT= Tipo.INT; :}
            | BOOL {: RESULT= Tipo.BOOLEAN; :}
            ;

ASIGNACION  ::= IGUAL EXPRESION:e {: RESULT= e; :}
            ;

EXPRESION   ::= VALOR:v OPERACION:o {: RESULT= PrioridadOperacion(new Expresion(v, o)); :}
            | LPAREN EXPRESION:e RPAREN OPERACION:o {: RESULT= new Expresion(e,o); :}
            ;

VALOR       ::= M ID:id {: verificaID(id); RESULT= new Valor(new Id(id)); :}
            | NUMERO:n {: RESULT = new Valor(new Numero(n)); :}
            | BOLEAN:b {: RESULT = new Valor(new Boleano(b)); :}
            | IN LPAREN RPAREN {: RESULT= new Valor(new In()); :}
            | M ID:i FUNCION:f {: seleccionID(i, new SentenciaId(f)); RESULT= new Valor(new IdSentencia(new Id(i), new SentenciaId(f))); :}
            ;

OPERACION   ::= OP:o EXPRESION:e {:  RESULT= new Operacion(o,e); :} 
            | {: :}
            ;

OP          ::= MULT {:  RESULT= Operaciones.MULT; :}
            | DIV {: RESULT= Operaciones.DIV; :}
            | SUMA {: RESULT= Operaciones.SUMA; :}
            | RESTA {: RESULT= Operaciones.RESTA; :}
            | MAYORQUE {: RESULT= Operaciones.MAYORQUE; :}
            | MENORQUE {:  RESULT= Operaciones.MENORQUE; :}
            | MAYORIGU {: RESULT= Operaciones.MAYORIGU; :}
            | MENORIGU {: RESULT= Operaciones.MENORIGU; :}
            | IGUALES {: RESULT= Operaciones.IGUALES; :}
            | NIGUALES {: RESULT= Operaciones.NIGUALES; :}
            | OR {: RESULT= Operaciones.OR; :}
            | AND {: RESULT= Operaciones.AND; :}
            ;

FUNCION     ::= LPAREN INPARAM:i RPAREN{: RESULT= i;  :}
            ;

INPARAM     ::= EXPRESION:e {: RESULT= new Param(e, null);  :}
            | EXPRESION:e COMA INPARAM:p {: RESULT= new Param(e, p);  :}
            | {:  :}
            ;

MF          ::= {: newBloque(cur_token); :}
            ;

MV          ::= {: newValor(cur_token); :}
            ;

M           ::= {: put(cur_token); :}
            ;