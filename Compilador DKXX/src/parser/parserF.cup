package parser;

import java_cup.runtime.*;
import parser.symbols.*;
import ArbolSintactico.ArbolSintactico;
import ArbolSintactico.ArbolSintactico.*;
import ArbolSintactico.Tipo;



parser code {:
    ArbolSintactico arbol= new ArbolSintactico();

public ArbolSintactico getArbol(){
    return arbol;
}
:};



terminal                           MULT, DIV, SUMA, RESTA, IGUAL, MAYORQUE, MENORQUE, MAYORIGU, MENORIGU, 
                                   IGUALES, OR, AND, NOT, LPAREN, RPAREN, LKEY, RKEY, RETRN, WHILE, IF, NIGUALES,
                                   OUT, IN, COMA, PUNTYCOMA, FUNCTION, CONST, INT, BOOL, DECLARE, MAIN;
terminal        String             ID;
terminal        String            NUMERO;
terminal        String            BOLEAN;

non terminal             INIT;
non terminal              DEF;

/** non terminal    SymbolProg         PROG; **/

non terminal         DFUNCION;
non terminal           RETURN;
non terminal        PARAMETRO;
non terminal      PARAMCONCAT;
non terminal      DECLARACION;
non terminal        DECLAREND;
non terminal             TYPE;
non terminal       ASIGNACION;
non terminal        EXPRESION;
non terminal            VALOR;
non terminal        OPERACION;
non terminal               OP;
non terminal          FUNCION;
non terminal          INPARAM;

non terminal SENTENCIA;
non terminal SENTENCIAS;
non terminal SENTENCIA_ID;

non terminal R_SENTENCIAS;
non terminal R_SENTENCIA;

precedence right    IGUAL;
precedence left     SUMA, RESTA;
precedence left     MULT, DIV;

start with INIT;

INIT    ::=     DECLARE LKEY DEF:d RKEY MAIN LKEY SENTENCIAS:m RKEY
                {: arbol.setRaiz(new Init(d,m)); :}
        ;

/** sentencias por prog antes **/

DEF     ::=    DFUNCION:f DEF:d {:RESULT =new Def(f,d); :}
        |      DECLARACION:f PUNTYCOMA DEF:d {: RESULT =new Def(f,d); :}
        |      {:   :}
        ;

SENTENCIAS ::= SENTENCIA:e SENTENCIAS:s {: RESULT=new Sentencias(e,s); :}
        |   {: :}
        ;

SENTENCIA ::= DECLARACION:d  PUNTYCOMA                         {: RESULT=d; :}
        | OUT LPAREN EXPRESION:e RPAREN PUNTYCOMA              {: RESULT= new Out(e); :}
        | ID:i SENTENCIA_ID:d PUNTYCOMA                          {: RESULT= new SentenciaID(i,d);:}
        | WHILE LPAREN EXPRESION:e RPAREN LKEY SENTENCIAS:s RKEY {: RESULT= new While(e,s);  :}
        | IF LPAREN EXPRESION:e RPAREN LKEY SENTENCIAS:s RKEY    {: RESULT= new If(e,s); :}
        | error PUNTYCOMA                                    {:  :}
        ;

R_SENTENCIAS ::= R_SENTENCIA:e R_SENTENCIAS:s {: RESULT=new Sentencias(e,s); :}
        |   {:  :}
        ;

R_SENTENCIA    ::= RETRN EXPRESION:e PUNTYCOMA  {: RESULT=new Return(e); :}
                | DECLARACION:d  PUNTYCOMA                         {: RESULT=d; :}
                | OUT LPAREN EXPRESION:e RPAREN PUNTYCOMA              {: RESULT= new Out(e); :}
                | ID:i SENTENCIA_ID:d PUNTYCOMA                          {: RESULT= new SentenciaID(i,d); :}
                | WHILE LPAREN EXPRESION:e RPAREN LKEY R_SENTENCIAS:s RKEY {: RESULT= new While(e,s);  :}
                | IF LPAREN EXPRESION:e RPAREN LKEY R_SENTENCIAS:s RKEY    {: RESULT= new If(e,s); :}
                | error PUNTYCOMA                                    {:  :}
                ;

SENTENCIA_ID    ::= ASIGNACION:a {: RESULT=a; :}
                | FUNCION:f {: RESULT=f; :}
                ;


DFUNCION    ::= FUNCTION RETURN:r ID:i LPAREN PARAMETRO:p RPAREN LKEY R_SENTENCIAS:s RKEY {: RESULT= new Dfuncion(i,r,p,s); :}
            ;


RETURN      ::= TYPE:t {: RESULT=t; :}
            | {:  :}
            ;

PARAMETRO   ::= TYPE:t ID:i PARAMCONCAT:d {: RESULT= new Dparam(t,i,d); :}
            | {:  :}
            ;

PARAMCONCAT ::= COMA TYPE:t ID:i PARAMCONCAT:d {: RESULT= new Dparam(t,i,d); :}
            | {:  :}
            ;

DECLARACION ::= CONST TYPE:t ID:i DECLAREND:d {: RESULT= new Declaracion(t,i,d); :}
            | TYPE:t ID:i DECLAREND:d {: RESULT= new Declaracion(t,i,d); :}
            ;

DECLAREND   ::= ASIGNACION:a {: RESULT=a; :}
            | {:  :}
            ;

TYPE        ::= INT {: RESULT= Tipo.INT; :}
            | BOOL {: RESULT= Tipo.BOOLEAN; :}
            ;

ASIGNACION  ::= IGUAL EXPRESION:e {: RESULT=e; :}
            ;

EXPRESION   ::= VALOR:v OPERACION:o {: RESULT= new Expresion(v,o); :}
            | LPAREN EXPRESION:e RPAREN OPERACION:o {: RESULT= new Expresion(e,o); :}
            ;

VALOR       ::= ID:id {:  RESULT=id; :}
            | NUMERO:n {: RESULT = n; :}
            | BOLEAN:b {: RESULT =b; :}
            | IN LPAREN RPAREN {:  RESULT= new In(); :}
            | ID:i FUNCION:f {:  RESULT= new Funcion(i,f); :}
            ;

OPERACION   ::= OP:o EXPRESION:e {:  RESULT= new Operacion(o,e); :} 
            | {: :}
            ;

OP          ::= MULT {:  RESULT= Operaciones.MULT; :}
            | DIV {: RESULT= Operaciones.DIV; :}
            | SUMA {: RESULT= Operaciones.SUMA; :}
            | RESTA {: RESULT= Operaciones.RESTA; :}
            | MAYORQUE {: RESULT= Operaciones.MAYORQUE; :}
            | MENORQUE {:  RESULT= Operaciones.MENORQUE; :}
            | MAYORIGU {: RESULT= Operaciones.MAYORIGU; :}
            | MENORIGU {: RESULT= Operaciones.MENORIGU; :}
            | IGUALES {: RESULT= Operaciones.IGUALES; :}
            | NIGUALES {: RESULT= Operaciones.NIGUALES; :}
            | OR {: RESULT= Operaciones.OR; :}
            | AND {: RESULT= Operaciones.AND; :}
            | NOT {: RESULT= Operaciones.NOT; :}
            ;

FUNCION     ::= LPAREN INPARAM:i RPAREN{: RESULT=i;  :}
            ;

INPARAM     ::= EXPRESION:e {: RESULT= new Param(e,null);  :}
            | EXPRESION:e COMA INPARAM:p {: RESULT= new Param(e,p);  :}
            | {:  :}
            ;
