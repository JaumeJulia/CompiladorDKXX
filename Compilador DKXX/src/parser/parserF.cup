package parser;

import java_cup.runtime.ComplexSymbolFactory.ComplexSymbol;
import java_cup.runtime.ComplexSymbolFactory.Location;

import java_cup.runtime.*;

import parser.symbols.*;

/**import java.io.PrintStream;**/
/**import java.util.HashMap;**/

class Parser;

/**
parser code {:
    Scanner s;
    Parser(Scanner s){ this.s=s; }
:}

init with {: s.init(); :};
scan with {: return s.next_token(); :};
**/

/**
parser code {:

    /private HashMap<String, Double>tsymbols = new HashMap<>();

    public Double getSymbolValue(String id){
        return tsymbols.get(id);
    }

    public void addSymbol(String id, Double value) {
        if (tsymbols.get(id) == null) {
            tsymbols.put(id, value);
        } else {
            tsymbols.replace(id, value);
        }
    }

    public void printVars(PrintStream out) {
        if (tsymbols.size() == 0) {
            out.println("No hi ha variables declarades");
        } else {
            String fmt = "%-8s: %f";
            tsymbols.forEach((k,v) -> out.println(String.format(fmt,k,v)));
        }
    }

    private boolean errorSemantic = false;

    @Override
    public void unrecovered_syntax_error(Symbol cur_token) throws Exception {
        report_error("Error sintàctic catastròfic", cur_token);
        done_parsing();        
    }

    @Override
    public void syntax_error(Symbol cur_token) {
        report_error("de sintaxis", cur_token);
    }

    @Override
    public void report_error(String message, Object info) {
        StringBuilder msg = new StringBuilder("ERROR");
        if (info instanceof Symbol) {
            ComplexSymbol token = (ComplexSymbol)info;
            Location l = token.getLeft();
            
            if (l != null) {
                msg.append(" (fila: ")
                   .append(l.getLine())
                   .append(", columna: ")
                   .append(l.getColumn())
                   .append(")");
            }
        }
        msg.append(": ").append(message);
        
        System.err.println(msg);
    }

    @Override
    public void report_fatal_error(String message, Object info) throws Exception {
        report_error("Error catastròfic ("+message+")", info);
        done_parsing();
    }

:}
**/

terminal                           MULT, DIV, SUMA, RESTA, IGUAL, MAYORQUE, MENORQUE, MAYORIGU, MENORIGU, 
                                   IGUALES, OR, AND, NOT, LPAREN, RPAREN, LKEY, RKEY, RETRN, WHILE, IF, NIGUALES,
                                   OUT, IN, COMA, PUNTYCOMA, FUNCTION, CONST, INT, BOOL, DECLARE, MAIN;
terminal        String             ID;
terminal        Integer            NUMERO;
terminal        Boolean            BOLEAN;

non terminal    SymbolInit         INIT;
non terminal    SymbolDef          DEF;

/** non terminal    SymbolProg         PROG; **/
non terminal         DFUNCION;
non terminal           RETURN;
non terminal        PARAMETRO;
non terminal      PARAMCONCAT;
non terminal      DECLARACION;
non terminal        DECLAREND;
non terminal             TYPE;
non terminal       ASIGNACION;
non terminal    SymbolExpresion    EXPRESION;
non terminal            VALOR;
non terminal    SymbolOperacion    OPERACION;
non terminal               OP;
non terminal          FUNCION;
non terminal          INPARAM;

non terminal SENTENCIA;
non terminal SENTENCIAS;
non terminal SENTENCIA_ID;

non terminal R_SENTENCIAS;

precedence right    IGUAL;
precedence left     SUMA, RESTA;
precedence left     MULT, DIV;

start with INIT;

INIT    ::=     DECLARE LKEY DEF RKEY MAIN LKEY SENTENCIAS RKEY
                {:  :}
        ;

/** sentencias por prog antes **/

DEF     ::=    DFUNCION DEF {:  :}
        |      DECLARACION DEF {:  :}
        |      {:  :}
        ;

SENTENCIAS ::= SENTENCIA SENTENCIAS {:  :}
        |   {:  :}
        ;

SENTENCIA ::= DECLARACION  PUNTYCOMA                         {:  :}
        | OUT LPAREN EXPRESION RPAREN PUNTYCOMA              {: :}
        | ID SENTENCIA_ID PUNTYCOMA                          {:  :}
        | WHILE LPAREN EXPRESION RPAREN LKEY SENTENCIAS RKEY {:  :}
        | IF LPAREN EXPRESION RPAREN LKEY R_SENTENCIAS RKEY    {:  :}
        | error PUNTYCOMA                                    {: /* regla para recuperar un error en una instrucción */ :}
        ;

R_SENTENCIAS    ::= RETRN EXPRESION:e PUNTYCOMA R_SENTENCIAS:s {: RETURN new Sentencias(new Return(e), s)}
                | SENTENCIAS {:  :}
                ;

SENTENCIA_ID    ::= ASIGNACION {:  :}
                | FUNCION {:  :}
                ;


DFUNCION    ::= FUNCTION RETURN ID LPAREN PARAMETRO RPAREN LKEY R_SENTENCIAS RKEY {:  :}
            ;


RETURN      ::= TYPE {:  :}
            | {:  :}
            ;

PARAMETRO   ::= TYPE ID PARAMCONCAT {:  :}
            | {:  :}
            ;

PARAMCONCAT ::= COMA TYPE ID PARAMCONCAT {:  :}
            | {:  :}
            ;

DECLARACION ::= CONST TYPE ID DECLAREND {:  :}
            | TYPE ID DECLAREND {:  :}
            ;

DECLAREND   ::= ASIGNACION {:  :}
            | {:  :}
            ;

TYPE        ::= INT {:  :}
            | BOOL {:  :}
            ;

ASIGNACION  ::= IGUAL EXPRESION {:  :}
            ;

EXPRESION   ::= VALOR OPERACION {:  :}
            | LPAREN EXPRESION RPAREN OPERACION {:  :}
            ;

VALOR       ::= ID {:  :}
            | NUMERO {: :}
            | BOLEAN {:  :}
            | IN LPAREN RPAREN PUNTYCOMA{:  :}
            | ID FUNCION {:  :}
            ;

OPERACION   ::= OP EXPRESION {: :} 
            | {: :}
            ;

OP          ::= MULT {:  :}
            | DIV {: :}
            | SUMA {:  :}
            | RESTA {:  :}
            | MAYORQUE {:  :}
            | MENORQUE {:  :}
            | MAYORIGU {:  :}
            | MENORIGU {:  :}
            | IGUALES {:  :}
            | NIGUALES {:  :}
            | OR {:  :}
            | AND {:  :}
            | NOT {:  :}
            ;

FUNCION     ::= LPAREN INPARAM RPAREN{:  :}
            ;

INPARAM     ::= EXPRESION {:  :}
            | EXPRESION COMA INPARAM {:  :}
            | {:  :}
            ;
