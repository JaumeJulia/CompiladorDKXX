package parser;

import java_cup.runtime.*;
import ArbolSintactico.ArbolSintactico;
import ArbolSintactico.ArbolSintactico.*;
import ArbolSintactico.Tipo;
import Semantico.Semantico;
import java.util.LinkedList;
import java.util.List;
import java.util.ArrayList;
import TablaSimbolos.TablaSimbolos;
import TablaSimbolos.TipoSub;

parser code {:
    ArbolSintactico arbol= new ArbolSintactico();
    ArrayList<String> errores = new ArrayList<>();
    TablaSimbolos ts = new TablaSimbolos();
    Semantico sem = new Semantico(ts);

    public ArbolSintactico getArbol(){
        return arbol;
    }

    public TablaSimbolos getTablaSimbolos(){
        return ts;
    }

    public Semantico getSemantico(){
        return sem;
    }

    //Semantico y Tabla de Simbolos. 
    private boolean addSim(String id, Tipo tipo, TipoSub tipoSub){;
        if(!ts.addSimbolo(id, tipo, tipoSub, cur_token.left)){
            sem.addError(4, cur_token.left, id);
            return false;
        }
        return true;
    }
    
    //Tratamiento errores.
    @Override
    public void syntax_error(Symbol cur_token) {
        String mensaje = "\t - " + cur_token.toString() + "." + this.showExpectedTokenIds() + " en linea " + cur_token.left + " en columna " + cur_token.right;
        this.report_error(mensaje, cur_token);
    }

    @Override
    public void report_fatal_error(String mensaje, Object info) {
        //report_error(mensaje, null);
    }

    @Override
    public void report_error(String mensaje, Object info) {
        errores.add(mensaje);
    }

    private String showExpectedTokenIds() {
        List<Integer> ids = this.expected_token_ids();
        LinkedList<String> list = new LinkedList<>();
        for (Integer expected : ids) {
            list.add(this.symbl_name_from_id(expected.intValue()));
        }
        if (list.size() > 0) {
            return " Se esperaba: " + list.toString();
        } else {
            return "";
        }
    }

    public boolean hayErrores(){
        return !errores.isEmpty();
    }

    public String toStringErrores(){
        String s = "";
        for(String e : errores){
            s += e + "\n";
        }
        return s;
    }
:};



terminal    MULT, DIV, SUMA, RESTA, IGUAL, MAYORQUE, MENORQUE, MAYORIGU, MENORIGU, 
            IGUALES, OR, AND, LPAREN, RPAREN, LKEY, RKEY, RETRN, WHILE, IF, NIGUALES,
            OUT, IN, COMA, PUNTYCOMA, FUNCTION, CONST, INT, BOOL, DECLARE, MAIN;

terminal        String      ID;
terminal        String      NUMERO;
terminal        String      BOLEAN;

non terminal    Init        INIT;
non terminal    Def         DEF;

non terminal    Dfuncion    DFUNCION;
non terminal    Tipo        RETURN;
non terminal    Dparam      PARAMETRO;
non terminal    Dparam      PARAMCONCAT;
non terminal    Declaracion DECLARACION;
non terminal    Expresion   DECLAREND;
non terminal    Tipo        TYPE;
non terminal    Expresion   ASIGNACION;
non terminal    Expresion   EXPRESION;
non terminal    Valor       VALOR;
non terminal    Operacion   OPERACION;
non terminal    Operaciones OP;
non terminal    Param       FUNCION;
non terminal    Param       INPARAM;

non terminal Sentencia      SENTENCIA;
non terminal Sentencias     SENTENCIAS;
non terminal SentenciaId    SENTENCIA_ID;

non terminal Sentencias     R_SENTENCIAS;
non terminal Sentencia      R_SENTENCIA;

non terminal                M;

start with INIT;

INIT    ::=     DECLARE LKEY DEF:d RKEY MAIN LKEY SENTENCIAS:m RKEY
                {: arbol.setRaiz(new Init(d, m)); :}
        ;

/** sentencias por prog antes **/

DEF     ::=    DFUNCION:f DEF:d {:RESULT = new Def(f,d); :}
        |      DECLARACION:f PUNTYCOMA DEF:d {: RESULT = new Def(f, d); :}
        |      {:   :}
        ;

SENTENCIAS ::= SENTENCIA:e SENTENCIAS:s {: RESULT = new Sentencias(e, s); :}
        |   {: :}
        ;

SENTENCIA ::= DECLARACION:d  PUNTYCOMA                         {: RESULT= new Sentencia(d); :}
        | OUT LPAREN EXPRESION:e RPAREN PUNTYCOMA              {: sem.verExpr(e, Tipo.INT, cur_token.left);
                                                                  RESULT= new Sentencia(new Out(e)); :}
        | ID:i SENTENCIA_ID:d PUNTYCOMA                          {: if(sem.verId(i, cur_token.left)){ sem.selOpId(i, d, cur_token.left);}
                                                                    RESULT= new Sentencia(new IdSentencia(new Id(i), d)); :}
        | WHILE LPAREN EXPRESION:e RPAREN LKEY SENTENCIAS:s RKEY {: sem.verExpr(e, Tipo.BOOLEAN, cur_token.left);
                                                                      RESULT= new Sentencia(new While(e, s));  :}
        | IF LPAREN EXPRESION:e RPAREN LKEY SENTENCIAS:s RKEY    {: sem.verExpr(e, Tipo.BOOLEAN, cur_token.left);
                                                                      RESULT= new Sentencia(new If(e, s)); :}
        | error PUNTYCOMA                                    {: parser.report_error("sentencia", "WRONG"); :}
        ;

R_SENTENCIAS ::= R_SENTENCIA:e R_SENTENCIAS:s {: RESULT= new Sentencias(e,s); :}
        |   {:  :}
        ;

R_SENTENCIA    ::= RETRN EXPRESION:e PUNTYCOMA  {: RESULT= new Sentencia(new Return(e)); :}
        | DECLARACION:d  PUNTYCOMA                         {: RESULT= new Sentencia(d); :}
        | OUT LPAREN EXPRESION:e RPAREN PUNTYCOMA              {: sem.verExpr(e, Tipo.INT, cur_token.left);
                                                                  RESULT= new Sentencia(new Out(e)); :}
        | ID:i SENTENCIA_ID:d PUNTYCOMA                          {: if(sem.verId(i, cur_token.left)){ sem.selOpId(i, d, cur_token.left);}
                                                                      RESULT= new Sentencia(new IdSentencia(new Id(i), d)); :}
        | WHILE LPAREN EXPRESION:e RPAREN LKEY R_SENTENCIAS:s RKEY {: sem.verExpr(e, Tipo.BOOLEAN, cur_token.left);
                                                                      RESULT= new Sentencia(new While(e, s));  :}
        | IF LPAREN EXPRESION:e RPAREN LKEY R_SENTENCIAS:s RKEY    {: sem.verExpr(e, Tipo.BOOLEAN, cur_token.left);
                                                                      RESULT= new Sentencia(new If(e, s)); :}
        | error PUNTYCOMA                                    {: parser.report_error("sentencia", "WRONG"); :}
        ;

SENTENCIA_ID    ::= ASIGNACION:a {: RESULT= new SentenciaId(a); :}
                | FUNCION:f {: RESULT= new SentenciaId(f); :}
                ;


DFUNCION    ::= FUNCTION M RETURN:r ID:i LPAREN PARAMETRO:p RPAREN LKEY R_SENTENCIAS:s RKEY {: sem.verRet(i, r, s, cur_token.left); addSim(i, r, TipoSub.FUNCION);
                                                                                                RESULT= new Dfuncion(new Id(i), r, p, s); :}
            ;

RETURN      ::= TYPE:t {: RESULT= t; :}
            | {: :}
            ;

PARAMETRO   ::= TYPE:t ID:i PARAMCONCAT:d {: addSim(i, t, TipoSub.PARAMETRO); 
                                                RESULT= new Dparam(t, new Id(i), d); :}
            | {:  :}
            ;

PARAMCONCAT ::= COMA TYPE:t ID:i PARAMCONCAT:d {: addSim(i, t, TipoSub.PARAMETRO); 
                                                     RESULT= new Dparam(t, new Id(i), d); :}
            | {:  :}
            ;

DECLARACION ::= CONST TYPE:t ID:i DECLAREND:d {: if(addSim(i, t, TipoSub.CONSTANTE)){sem.verConst(i, d, cur_token.left);}
                                                    RESULT= new Declaracion(t, new Id(i), d); :}
            | TYPE:t ID:i DECLAREND:d {: if(addSim(i, t, TipoSub.VARIABLE)){sem.verVar(i, d, cur_token.left);}
                                            RESULT= new Declaracion(t, new Id(i), d); :}
            ;

DECLAREND   ::= ASIGNACION:a {: RESULT= a; :}
            | {:  :}
            ;

TYPE        ::= INT {: RESULT= Tipo.INT; :}
            | BOOL {: RESULT= Tipo.BOOLEAN; :}
            ;

ASIGNACION  ::= IGUAL EXPRESION:e {: RESULT= e; :}
            ;

EXPRESION   ::= VALOR:v OPERACION:o {: RESULT= sem.priOp(new Expresion(v, o)); :}
            | LPAREN EXPRESION:e RPAREN OPERACION:o {: RESULT= new Expresion(e,o); :}
            ;

VALOR       ::= ID:id {: sem.verId(id, cur_token.left);
                           RESULT= new Valor(new Id(id)); :}
            | NUMERO:n {: RESULT = new Valor(new Numero(n)); :}
            | BOLEAN:b {: RESULT = new Valor(new Boleano(b)); :}
            | IN LPAREN RPAREN {: RESULT= new Valor(new In()); :}
            | ID:i FUNCION:f {: if(sem.verId(i, cur_token.left)){ sem.verFunc(i, f, cur_token.left); }
                                  RESULT= new Valor(new IdSentencia(new Id(i), new SentenciaId(f))); :}
            ;

OPERACION   ::= OP:o EXPRESION:e {: RESULT= new Operacion(o,e); :} 
            | {: :}
            ;

OP          ::= MULT {:  RESULT= Operaciones.MULT; :}
            | DIV {: RESULT= Operaciones.DIV; :}
            | SUMA {: RESULT= Operaciones.SUMA; :}
            | RESTA {: RESULT= Operaciones.RESTA; :}
            | MAYORQUE {: RESULT= Operaciones.MAYORQUE; :}
            | MENORQUE {:  RESULT= Operaciones.MENORQUE; :}
            | MAYORIGU {: RESULT= Operaciones.MAYORIGU; :}
            | MENORIGU {: RESULT= Operaciones.MENORIGU; :}
            | IGUALES {: RESULT= Operaciones.IGUALES; :}
            | NIGUALES {: RESULT= Operaciones.NIGUALES; :}
            | OR {: RESULT= Operaciones.OR; :}
            | AND {: RESULT= Operaciones.AND; :}
            ;

FUNCION     ::= LPAREN INPARAM:i RPAREN{: RESULT= i;  :}
            ;

INPARAM     ::= EXPRESION:e {: RESULT= new Param(e, null);  :}
            | EXPRESION:e COMA INPARAM:p {: RESULT= new Param(e, p);  :}
            | {:  :}
            ;

M           ::= {: ts.addnivel(); :}
            ;